<%@ CodeTemplate Language="C#" TargetLanguage="C#" Debug="True" Description="Generate SQL Insert Statements from table data." ResponseEncoding="UTF-8" %>

<%@ Assembly Name="SchemaExplorer" %>
<%@ Assembly Name="System.Design" %>
<%@ Assembly Name="System.Data" %>
<%@ Assembly Name="CodeSmith.CustomProperties" %>
<%@ Assembly Name="System" %>
<%@ Import Namespace="System.Collections.Generic" %>


<%@ Property Category="Data" Name="SourceTable" Optional="False"
    Type="CodeSmith.CustomProperties.StringCollection" 
    Description="Data Source" %>
//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由梁爽制作的工具于【<%= DateTime.Now.ToString("yyyy-MM-dd hh:mm:ss") %>】生成。
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UAPLibrary.Utility;

namespace UAPLibrary.Packet
{
<% foreach (String line in this.SourceTable) {  %>
<% 
string[] strs = line.Split(new string[]{":"}, StringSplitOptions.RemoveEmptyEntries);
string[] str1 = strs[0].Split(new string[]{"|"}, StringSplitOptions.RemoveEmptyEntries);
string[] str2 = null;
List<KeyValuePair<string, string>> strPair = new List<KeyValuePair<string, string>>();
if (strs.Length > 1)
{
    str2 = strs[1].Split(new string[]{"&"}, StringSplitOptions.RemoveEmptyEntries);
    for (int i = 0; i < str2.Length; ++i)
    {
        string[] tempStr = str2[i].Split(new string[]{"|"}, StringSplitOptions.RemoveEmptyEntries);
        strPair.Add(new KeyValuePair<string, string>(tempStr[0], tempStr[1]));
    }
}
string uapPacketName = str1[0]; 
string uapSummary = str1[2]; 
%>

    #region Uap<%=uapPacketName%>:<%=uapSummary%>
    /// <summary>
    /// <%=uapSummary%>
    /// </summary>
    public partial class Uap<%=uapPacketName%> : <%if (uapPacketName == "Begin" || uapPacketName == "Continue" || uapPacketName == "End" || uapPacketName == "SwitchBegin") 
{ %>UapMessageBase<% } else { %>UapBase<% } %>
    {
<%if (strPair.Count > 0)
{ %>
        #region constants

<% foreach (KeyValuePair<string, string> pair in strPair) {  %>
<%bool flag = false;
if (!pair.Value.StartsWith("U") && pair.Value != "0")
{ %>
<%if (uapPacketName == "Begin" || uapPacketName == "Continue" || uapPacketName == "End" || uapPacketName == "SwitchBegin") 
{ 
    if (pair.Key != "UssdVersion" && pair.Key != "UssdOpType" && pair.Key != "MsIsdn" 
        && pair.Key != "ServiceCode" && pair.Key != "CodeScheme" && pair.Key != "UssdContent")
    {
        flag = true;
    }
} else { 
    flag = true;
} %>
<%if (flag)
{ %>
        private const int <%= pair.Key.ToUpper() %>_LENGTH = <%= pair.Value %>;
<% } %>
<% } %>
<% } %>
        #endregion constants
<% } %>
<%if (strPair.Count > 0)
{ %>

        #region properties

<% foreach (KeyValuePair<string, string> pair in strPair) {  %>
<%bool flag = false;
if (uapPacketName == "Begin" || uapPacketName == "Continue" || uapPacketName == "End" || uapPacketName == "SwitchBegin") 
{ 
    if (pair.Key != "UssdVersion" && pair.Key != "UssdOpType" && pair.Key != "MsIsdn" 
        && pair.Key != "ServiceCode" && pair.Key != "CodeScheme" && pair.Key != "UssdContent")
    {
        flag = true;
    }
} else { 
    flag = true;
} %>
<%if (flag)
{ %>
<%if (pair.Value == "U4")
{ %>
        public uint <%= StringUtil.ToPascalCase(pair.Key) %> { get; set; }
<% } else if (pair.Key == "UssdOpType")
{ %>
        public UssdOpTypeEnum <%= StringUtil.ToPascalCase(pair.Key) %> { get; set; }
<% } else if (pair.Key == "UssdVersion")
{ %>
        public UssdVersionEnum <%= StringUtil.ToPascalCase(pair.Key) %> { get; set; }
<% } else if (pair.Value == "U1")
{ %>
        public byte <%= StringUtil.ToPascalCase(pair.Key) %> { get; set; }
<% } else if (pair.Value == "0")
{ %>
        public string <%= StringUtil.ToPascalCase(pair.Key) %> { get; set; }
<% } else { %>
        private string _<%= StringUtil.ToCamelCase(pair.Key) %>;
        public string <%= StringUtil.ToPascalCase(pair.Key) %>
        {
            get
            {
                return _<%= StringUtil.ToCamelCase(pair.Key) %>;
            }
            set
            {
                if (value != null)
                {
                    if (value.Length < <%= pair.Key.ToUpper() %>_LENGTH)
                    {
                        _<%= StringUtil.ToCamelCase(pair.Key) %> = value;
                    }
                    else
                    {
                        throw new ArgumentOutOfRangeException("<%= StringUtil.ToPascalCase(pair.Key) %> 必须小于 " + <%= pair.Key.ToUpper() %>_LENGTH + " 个字符");
                    }
                }
                else
                {
                    _<%= StringUtil.ToCamelCase(pair.Key) %> = string.Empty;
                }
            }
        }
<% } %>
<% } %>
<% } %>

        #endregion properties
<% } %>

        #region constructors

        public Uap<%=uapPacketName%>() : base() { }
        public Uap<%=uapPacketName%>(byte[] incomingBytes) : base(incomingBytes) { }

        protected override void InitUap()
        {
            base.InitUap();
            CommandId = CommandIdType.<%=uapPacketName%>;
        }

        #endregion constructors
        
        #region Encode & Decode

        protected override void DecodeBody()
        {
<%if (strPair.Count > 0)
{ %>
            int pos = HEADER_LENGTH;
<% } %>
<% foreach (KeyValuePair<string, string> pair in strPair) {  %>
<%if (pair.Value == "U4")
{ %>
            this.<%= StringUtil.ToPascalCase(pair.Key) %> = BitConverter.ToUInt32(_packetBytes, pos);
            pos += 4;
<% } else if (pair.Key == "UssdOpType")
{ %>
            this.<%= StringUtil.ToPascalCase(pair.Key) %> = (UssdOpTypeEnum)_packetBytes[pos];
            pos += 1;
<% } else if (pair.Key == "UssdVersion")
{ %>
            this.<%= StringUtil.ToPascalCase(pair.Key) %> = (UssdVersionEnum)_packetBytes[pos];
            pos += 1;
<% } else if (pair.Value == "U1")
{ %>
            this.<%= StringUtil.ToPascalCase(pair.Key) %> = _packetBytes[pos];
            pos += 1;
<% } else if (pair.Value == "0")
{ %>
            this.<%= StringUtil.ToPascalCase(pair.Key) %> = StringUtility.GetOctetStringFromBytes(_packetBytes, pos);
<% } else { %>
            this._<%= StringUtil.ToCamelCase(pair.Key) %> = StringUtility.GetCOctetStringFromBytes(_packetBytes, pos, <%= pair.Key.ToUpper() %>_LENGTH);
            pos += <%= pair.Key.ToUpper() %>_LENGTH;
<% } %>
<% } %>
        }

        protected override byte[] EncodeBody()
        {
            List<byte> packet = new List<byte>();
<% foreach (KeyValuePair<string, string> pair in strPair) {  %>
<%if (pair.Value == "U4")
{ %>
            packet.AddRange(BitConverter.GetBytes(this.<%= StringUtil.ToPascalCase(pair.Key) %>));
<% } else if (pair.Value == "U1")
{ %>
            packet.Add((byte)this.<%= StringUtil.ToPascalCase(pair.Key) %>);
<% } else if (pair.Value == "0")
{ %>
            packet.AddRange(StringUtility.GetBytesFromOctetString(this.<%= StringUtil.ToPascalCase(pair.Key) %>));
<% } else { %>
            packet.AddRange(StringUtility.GetBytesFromCOctetString(this._<%= StringUtil.ToCamelCase(pair.Key) %>, <%= pair.Key.ToUpper() %>_LENGTH));
<% } %>
<% } %>
            return packet.ToArray();
        }
        
        #endregion Encode & Decode

    }
    #endregion Uap<%=uapPacketName%>:<%=uapSummary%>
<% } %>
}